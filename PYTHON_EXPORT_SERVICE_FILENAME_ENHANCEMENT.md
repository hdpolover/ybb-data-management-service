# Python Export Service - Filename Enhancement Implementation Guide

## Overview
This document provides implementation instructions for the Python Flask export service to handle the enhanced filename and sheet name functionality from the YBB Web Admin CodeIgniter application.

## Changes Required

### 1. Enhanced Request Payload Structure

The CodeIgniter application now sends additional parameters in the export request:

```json
{
  "export_type": "participants|payments|ambassadors",
  "program_id": 123,
  "data": [...],
  "template": "standard|detailed|custom",
  "format": "excel|csv|pdf",
  "filename": "Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025.xlsx",
  "sheet_name": "Participants Data Jul 2025",
  "filters": {
    // Applied filters
  },
  "options": {
    "include_related": true,
    "batch_size": 5000,
    "sort_by": "created_at",
    "sort_order": "desc"
  }
}
```

### 2. New Required Fields

#### `filename` (string, optional)
- **Purpose**: Descriptive filename generated by CodeIgniter based on program name, export type, and filters
- **Format**: `{Program_Name}_{Export_Type}_{Filters}_{Date}.xlsx`
- **Examples**: 
  - `Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025.xlsx`
  - `Global_Leadership_Program_Payments_Successful_IDR_Report_26-07-2025.xlsx`
  - `ASEAN_Youth_Forum_Ambassadors_List_26-07-2025.xlsx`
- **Fallback**: If not provided, use existing naming convention

#### `sheet_name` (string, optional)
- **Purpose**: Excel worksheet name for better organization
- **Format**: Descriptive name with month/year
- **Examples**:
  - `Participants Data Jul 2025`
  - `Successful Payments Jul 2025`
  - `Ambassadors Jul 2025`
- **Fallback**: If not provided, use generic sheet names

## Implementation Requirements

### 3. API Endpoint Updates

#### Single File Export Response
Update the response structure to include the original filename:

```json
{
  "status": "success",
  "message": "Export completed successfully",
  "data": {
    "export_id": "unique_export_id",
    "file_name": "Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025.xlsx",
    "file_url": "https://api.example.com/downloads/export_id.xlsx",
    "file_size": 1048576,
    "record_count": 1250,
    "expires_at": "2025-07-27T10:30:00Z"
  },
  "metadata": {
    "export_type": "participants",
    "template": "standard",
    "processing_time": 15.3,
    "generated_at": "2025-07-26T10:30:00Z"
  }
}
```

#### Multi-File Export Response
For large datasets split into multiple files:

```json
{
  "status": "success",
  "message": "Large export completed successfully",
  "export_strategy": "multi_file",
  "data": {
    "export_id": "unique_export_id",
    "total_records": 15000,
    "total_files": 3,
    "individual_files": [
      {
        "batch_number": 1,
        "file_name": "Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025_batch_1_of_3.xlsx",
        "file_url": "https://api.example.com/downloads/export_id_batch_1.xlsx",
        "file_size": 5242880,
        "record_count": 5000,
        "record_range": "1-5000"
      },
      {
        "batch_number": 2,
        "file_name": "Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025_batch_2_of_3.xlsx",
        "file_url": "https://api.example.com/downloads/export_id_batch_2.xlsx",
        "file_size": 5242880,
        "record_count": 5000,
        "record_range": "5001-10000"
      },
      {
        "batch_number": 3,
        "file_name": "Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025_batch_3_of_3.xlsx",
        "file_url": "https://api.example.com/downloads/export_id_batch_3.xlsx",
        "file_size": 2621440,
        "record_count": 5000,
        "record_range": "10001-15000"
      }
    ],
    "archive": {
      "zip_file_name": "Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025_complete_export.zip",
      "zip_file_url": "https://api.example.com/downloads/export_id_complete.zip",
      "zip_file_size": 12582912,
      "compression_ratio": "0.75"
    }
  }
}
```

### 4. File Naming Logic Implementation

#### Python Flask Code Example

```python
import os
import re
from datetime import datetime
from pathlib import Path

class ExportFileManager:
    def __init__(self):
        self.base_storage_path = "/app/exports/"
        
    def generate_filename(self, request_data, export_id, batch_info=None):
        """
        Generate appropriate filename based on request data
        
        Args:
            request_data (dict): The export request payload
            export_id (str): Unique export identifier
            batch_info (dict): Batch information for multi-file exports
            
        Returns:
            str: Generated filename
        """
        # Use provided filename if available
        if 'filename' in request_data and request_data['filename']:
            base_filename = request_data['filename']
            
            # Handle batch files
            if batch_info:
                # Remove .xlsx extension and add batch info
                base_name = base_filename.replace('.xlsx', '')
                batch_suffix = f"_batch_{batch_info['number']}_of_{batch_info['total']}"
                return f"{base_name}{batch_suffix}.xlsx"
            
            return base_filename
        
        # Fallback to existing naming convention
        export_type = request_data.get('export_type', 'export')
        date_str = datetime.now().strftime('%d-%m-%Y')
        
        if batch_info:
            return f"{export_type}_{export_id}_batch_{batch_info['number']}_{date_str}.xlsx"
        
        return f"{export_type}_{export_id}_{date_str}.xlsx"
    
    def generate_zip_filename(self, request_data, export_id):
        """Generate ZIP archive filename"""
        if 'filename' in request_data and request_data['filename']:
            base_filename = request_data['filename'].replace('.xlsx', '')
            return f"{base_filename}_complete_export.zip"
        
        export_type = request_data.get('export_type', 'export')
        date_str = datetime.now().strftime('%d-%m-%Y')
        return f"{export_type}_{export_id}_complete_{date_str}.zip"
    
    def get_sheet_name(self, request_data, batch_info=None):
        """
        Get Excel sheet name from request or generate default
        
        Args:
            request_data (dict): The export request payload
            batch_info (dict): Batch information for multi-file exports
            
        Returns:
            str: Sheet name for Excel file
        """
        # Use provided sheet name if available
        if 'sheet_name' in request_data and request_data['sheet_name']:
            sheet_name = request_data['sheet_name']
            
            # Add batch info if needed
            if batch_info:
                return f"{sheet_name} (Batch {batch_info['number']})"
            
            return sheet_name
        
        # Generate default sheet name
        export_type = request_data.get('export_type', 'Data')
        date_str = datetime.now().strftime('%b %Y')
        
        if batch_info:
            return f"{export_type.title()} {date_str} (Batch {batch_info['number']})"
        
        return f"{export_type.title()} {date_str}"
    
    def sanitize_filename(self, filename):
        """
        Sanitize filename to ensure it's safe for filesystem
        
        Args:
            filename (str): Original filename
            
        Returns:
            str: Sanitized filename
        """
        # Remove or replace invalid characters
        sanitized = re.sub(r'[<>:"/\\|?*]', '_', filename)
        
        # Limit length to prevent issues
        if len(sanitized) > 200:
            name, ext = os.path.splitext(sanitized)
            sanitized = name[:200-len(ext)] + ext
        
        return sanitized
```

#### Usage in Export Endpoints

```python
from flask import Flask, request, jsonify
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows

app = Flask(__name__)
file_manager = ExportFileManager()

@app.route('/api/ybb/export/participants', methods=['POST'])
def export_participants():
    request_data = request.get_json()
    export_id = generate_unique_id()
    
    try:
        # Get data and determine if chunking is needed
        data = request_data.get('data', [])
        batch_size = request_data.get('options', {}).get('batch_size', 5000)
        
        if len(data) <= batch_size:
            # Single file export
            filename = file_manager.generate_filename(request_data, export_id)
            sheet_name = file_manager.get_sheet_name(request_data)
            
            # Create Excel file
            file_path = create_excel_file(data, filename, sheet_name, request_data)
            
            return jsonify({
                "status": "success",
                "message": "Export completed successfully",
                "data": {
                    "export_id": export_id,
                    "file_name": filename,
                    "file_url": f"/api/ybb/export/{export_id}/download",
                    "file_size": os.path.getsize(file_path),
                    "record_count": len(data),
                    "expires_at": get_expiry_time()
                }
            })
        else:
            # Multi-file export
            return handle_multi_file_export(request_data, export_id, data, batch_size)
            
    except Exception as e:
        return jsonify({
            "status": "error",
            "message": f"Export failed: {str(e)}"
        }), 500

def create_excel_file(data, filename, sheet_name, request_data):
    """
    Create Excel file with proper filename and sheet name
    
    Args:
        data (list): Export data
        filename (str): Target filename
        sheet_name (str): Excel sheet name
        request_data (dict): Original request data
        
    Returns:
        str: Path to created file
    """
    # Sanitize names
    safe_filename = file_manager.sanitize_filename(filename)
    safe_sheet_name = sheet_name[:31]  # Excel sheet name limit
    
    # Create workbook
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = safe_sheet_name
    
    # Add data to worksheet
    if data:
        # Add headers
        headers = list(data[0].keys())
        ws.append(headers)
        
        # Add data rows
        for row in data:
            ws.append([row.get(header, '') for header in headers])
    
    # Save file
    file_path = os.path.join(file_manager.base_storage_path, safe_filename)
    wb.save(file_path)
    
    return file_path

def handle_multi_file_export(request_data, export_id, data, batch_size):
    """Handle large dataset export with multiple files"""
    total_records = len(data)
    total_batches = (total_records + batch_size - 1) // batch_size
    
    individual_files = []
    batch_files = []
    
    for batch_num in range(1, total_batches + 1):
        start_idx = (batch_num - 1) * batch_size
        end_idx = min(start_idx + batch_size, total_records)
        batch_data = data[start_idx:end_idx]
        
        batch_info = {
            'number': batch_num,
            'total': total_batches
        }
        
        # Generate batch filename and sheet name
        batch_filename = file_manager.generate_filename(request_data, export_id, batch_info)
        batch_sheet_name = file_manager.get_sheet_name(request_data, batch_info)
        
        # Create batch file
        batch_file_path = create_excel_file(batch_data, batch_filename, batch_sheet_name, request_data)
        batch_files.append(batch_file_path)
        
        individual_files.append({
            "batch_number": batch_num,
            "file_name": batch_filename,
            "file_url": f"/api/ybb/export/{export_id}/download/batch/{batch_num}",
            "file_size": os.path.getsize(batch_file_path),
            "record_count": len(batch_data),
            "record_range": f"{start_idx + 1}-{end_idx}"
        })
    
    # Create ZIP archive
    zip_filename = file_manager.generate_zip_filename(request_data, export_id)
    zip_path = create_zip_archive(batch_files, zip_filename)
    
    return jsonify({
        "status": "success",
        "message": "Large export completed successfully",
        "export_strategy": "multi_file",
        "data": {
            "export_id": export_id,
            "total_records": total_records,
            "total_files": total_batches,
            "individual_files": individual_files,
            "archive": {
                "zip_file_name": zip_filename,
                "zip_file_url": f"/api/ybb/export/{export_id}/download/zip",
                "zip_file_size": os.path.getsize(zip_path),
                "compression_ratio": calculate_compression_ratio(batch_files, zip_path)
            }
        }
    })
```

### 5. Download Endpoint Updates

```python
@app.route('/api/ybb/export/<export_id>/download', methods=['GET'])
def download_export(export_id):
    """Download single export file"""
    try:
        export_info = get_export_info(export_id)
        file_path = export_info['file_path']
        original_filename = export_info.get('filename', f'export_{export_id}.xlsx')
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=original_filename,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        
    except FileNotFoundError:
        return jsonify({"error": "Export file not found"}), 404

@app.route('/api/ybb/export/<export_id>/download/batch/<int:batch_number>', methods=['GET'])
def download_batch_file(export_id, batch_number):
    """Download specific batch file"""
    try:
        batch_info = get_batch_file_info(export_id, batch_number)
        file_path = batch_info['file_path']
        original_filename = batch_info.get('filename', f'export_{export_id}_batch_{batch_number}.xlsx')
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=original_filename,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        
    except FileNotFoundError:
        return jsonify({"error": "Batch file not found"}), 404

@app.route('/api/ybb/export/<export_id>/download/zip', methods=['GET'])
def download_export_zip(export_id):
    """Download ZIP archive"""
    try:
        zip_info = get_zip_file_info(export_id)
        file_path = zip_info['file_path']
        original_filename = zip_info.get('zip_filename', f'export_{export_id}.zip')
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=original_filename,
            mimetype='application/zip'
        )
        
    except FileNotFoundError:
        return jsonify({"error": "ZIP file not found"}), 404
```

### 6. Database Schema Updates

If using a database to track exports, update the schema to store filename information:

```sql
-- Add columns to exports table
ALTER TABLE exports ADD COLUMN original_filename VARCHAR(255);
ALTER TABLE exports ADD COLUMN sheet_name VARCHAR(100);
ALTER TABLE exports ADD COLUMN zip_filename VARCHAR(255);

-- Add columns to export_batches table (if exists)
ALTER TABLE export_batches ADD COLUMN batch_filename VARCHAR(255);
ALTER TABLE export_batches ADD COLUMN batch_sheet_name VARCHAR(100);
```

### 7. Configuration Updates

Add configuration for filename handling:

```python
# config.py
class Config:
    # Existing configurations...
    
    # Filename handling
    MAX_FILENAME_LENGTH = 200
    FILENAME_SANITIZATION_ENABLED = True
    EXCEL_SHEET_NAME_MAX_LENGTH = 31
    
    # File storage
    EXPORT_STORAGE_PATH = "/app/exports/"
    EXPORT_RETENTION_HOURS = 24
```

## Testing Requirements

### 8. Test Cases

Create comprehensive tests for the filename functionality:

```python
import unittest
from unittest.mock import patch, MagicMock

class TestFilenameEnhancement(unittest.TestCase):
    
    def setUp(self):
        self.file_manager = ExportFileManager()
        
    def test_custom_filename_single_file(self):
        """Test custom filename for single file export"""
        request_data = {
            'filename': 'Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025.xlsx',
            'sheet_name': 'Participants Data Jul 2025'
        }
        
        filename = self.file_manager.generate_filename(request_data, 'test_id')
        sheet_name = self.file_manager.get_sheet_name(request_data)
        
        self.assertEqual(filename, 'Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025.xlsx')
        self.assertEqual(sheet_name, 'Participants Data Jul 2025')
        
    def test_custom_filename_batch_files(self):
        """Test custom filename for batch files"""
        request_data = {
            'filename': 'Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025.xlsx',
            'sheet_name': 'Participants Data Jul 2025'
        }
        batch_info = {'number': 2, 'total': 5}
        
        filename = self.file_manager.generate_filename(request_data, 'test_id', batch_info)
        sheet_name = self.file_manager.get_sheet_name(request_data, batch_info)
        
        expected_filename = 'Japan_Youth_Summit_Participants_Complete_Registration_Data_26-07-2025_batch_2_of_5.xlsx'
        expected_sheet_name = 'Participants Data Jul 2025 (Batch 2)'
        
        self.assertEqual(filename, expected_filename)
        self.assertEqual(sheet_name, expected_sheet_name)
        
    def test_fallback_filename(self):
        """Test fallback when no custom filename provided"""
        request_data = {'export_type': 'participants'}
        
        filename = self.file_manager.generate_filename(request_data, 'test_id')
        
        self.assertTrue(filename.startswith('participants_test_id_'))
        self.assertTrue(filename.endswith('.xlsx'))
        
    def test_filename_sanitization(self):
        """Test filename sanitization"""
        dangerous_filename = 'Test<>:"/\\|?*File.xlsx'
        sanitized = self.file_manager.sanitize_filename(dangerous_filename)
        
        self.assertNotIn('<', sanitized)
        self.assertNotIn('>', sanitized)
        self.assertNotIn(':', sanitized)
        
    def test_long_filename_truncation(self):
        """Test long filename truncation"""
        long_filename = 'A' * 250 + '.xlsx'
        sanitized = self.file_manager.sanitize_filename(long_filename)
        
        self.assertLessEqual(len(sanitized), 200)
        self.assertTrue(sanitized.endswith('.xlsx'))

if __name__ == '__main__':
    unittest.main()
```

## Deployment Checklist

### 9. Pre-Deployment Steps

1. **Update Dependencies**
   ```bash
   pip install openpyxl flask pathlib
   ```

2. **Environment Variables**
   ```bash
   export EXPORT_STORAGE_PATH="/app/exports/"
   export MAX_FILENAME_LENGTH=200
   export EXCEL_SHEET_NAME_MAX_LENGTH=31
   ```

3. **File Permissions**
   ```bash
   mkdir -p /app/exports
   chmod 755 /app/exports
   chown app:app /app/exports
   ```

4. **Database Migration** (if applicable)
   ```bash
   python manage.py migrate
   ```

### 10. Post-Deployment Verification

1. **Test Custom Filename**
   ```bash
   curl -X POST https://your-api.com/api/ybb/export/participants \
     -H "Content-Type: application/json" \
     -d '{
       "data": [...],
       "filename": "Test_Program_Participants_26-07-2025.xlsx",
       "sheet_name": "Test Participants Jul 2025"
     }'
   ```

2. **Verify Response Structure**
   - Check that `file_name` matches the provided filename
   - Verify batch files include batch information in filenames
   - Confirm ZIP archives use descriptive names

3. **Download Tests**
   - Test single file downloads with correct filename
   - Test batch file downloads with proper naming
   - Test ZIP archive downloads with descriptive names

## Backward Compatibility

### 11. Legacy Support

The implementation must maintain backward compatibility:

- If `filename` is not provided, use existing naming convention
- If `sheet_name` is not provided, use generic sheet names
- Existing API endpoints must continue to work without changes
- Old export files should remain downloadable

## Error Handling

### 12. Error Scenarios

Handle these error cases gracefully:

1. **Invalid Filename Characters**
   - Sanitize automatically
   - Log warning but continue processing

2. **Filename Too Long**
   - Truncate while preserving extension
   - Log warning with original filename

3. **Missing Export Data**
   - Return appropriate error response
   - Include suggested filename in error details

4. **Sheet Name Issues**
   - Truncate to Excel limits (31 characters)
   - Handle special characters

## Performance Considerations

### 13. Optimization Notes

- Cache sanitized filenames to avoid repeated processing
- Use streaming for large file generation
- Implement proper cleanup of temporary files
- Monitor storage usage and implement retention policies

---

## Summary

This enhancement provides:

1. **Descriptive Filenames**: Program-specific, filter-aware naming
2. **Custom Sheet Names**: Meaningful Excel worksheet names
3. **Batch File Support**: Proper naming for multi-file exports
4. **ZIP Archive Names**: Descriptive archive filenames
5. **Backward Compatibility**: Existing functionality preserved
6. **Robust Error Handling**: Graceful handling of edge cases

The implementation ensures that exported files have meaningful names that clearly indicate their content, making file management easier for administrators and end users.
